/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, useState } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import useSceneStore from "../stores/useSceneStore";
import useDoorStore from "../stores/useDoorStore";
import useKeyPress from "../hooks/useKeyPress";

export default function Model({ ...props }) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/avatar5.glb");
  const { actions } = useAnimations(animations, group);
  const savedPos = useRef({ position: { z: 0, x: 0 }, rotation: { y: 0 } });

  //keyboard controls
  const wPress = useKeyPress("w");
  const aPress = useKeyPress("a");
  const dPress = useKeyPress("d");

  //raycaster setup
  const [visit, setVisit] = useState(null);

  const objects = [];
  let raycaster;
  const prev = useRef(null);
  const next = useRef(null);
  const nextDoor = useRef(null);

  let onObject = [];

  raycaster = new THREE.Raycaster(
    new THREE.Vector3(),
    new THREE.Vector3(0, -1, 0),
    0,
    10
  );

  // useEffect to handle scene change on plates

  const sceneStore = useSceneStore();
  const doorStore = useDoorStore();

  useEffect(() => {
    if (visit) {
      if (visit === next.current.uuid) {
        sceneStore.next(sceneStore.scene + 1);
        doorStore.next(doorStore.scene + 1);
      }
      if (visit === prev.current.uuid) {
        sceneStore.prev(sceneStore.scene - 1);
        doorStore.prev(doorStore.scene - 1);
      }

      visit === nextDoor.current.uuid && doorStore.toggleNextPlate(true);
    }
    doorStore.nextPlateState && doorStore.toggleNextPlate(false);
  }, [visit]);

  useFrame((state, delta) => {
    // Adding all the plates ref to an array which will be used to check intersection of raycaster with plates.
    !objects.includes(next.current) && objects.push(next.current);
    !objects.includes(prev.current) && objects.push(prev.current);
    !objects.includes(nextDoor.current) && objects.push(nextDoor.current);

    // Moving raycaster around with change of camera location
    raycaster.ray.origin.copy(group.current.position);
    // check if raycaster intersected with any of the plates
    onObject = raycaster.intersectObjects(objects);
    if (onObject.length > 0 && onObject[0].object) {
      setVisit(onObject[0].object.uuid);
    } else {
      setVisit(false);
    }

    const moveDistance = 5 * delta; // 200 pixels per second
    const rotateAngle = (Math.PI / 2) * delta; // pi/2 radians (90 degrees) per second

    if (!wPress) {
      actions["walk"].stop();

      actions["idle"].play();

      group.current.position.z = savedPos.current.position.z;
      group.current.position.x = savedPos.current.position.x;
    }

    if (wPress) {
      actions["idle"].stop();

      actions["walk"].play();

      group.current.position.z = savedPos.current.position.z;
      group.current.position.x = savedPos.current.position.x;

      group.current.translateZ(moveDistance);
      savedPos.current.position.z = group.current.position.z;
      savedPos.current.position.x = group.current.position.x;
    }

    if (aPress) {
      group.current.rotation.y = group.current.rotation.y + rotateAngle;
    }
    if (dPress) {
      group.current.rotation.y = group.current.rotation.y - rotateAngle;
    }
    const relativeCameraOffset = new THREE.Vector3(-0.6, 1.9, -4);
    const thirdPersonTarget = new THREE.Vector3(0, 2.1, 5);

    var cameraOffset = relativeCameraOffset.applyMatrix4(
      group.current.matrixWorld
    );
    var targetOffset = thirdPersonTarget.applyMatrix4(
      group.current.matrixWorld
    );

    state.camera.position.x = cameraOffset.x;
    state.camera.position.y = cameraOffset.y;
    state.camera.position.z = cameraOffset.z;
    state.camera.lookAt(targetOffset);
  });
  return (
    <>
      <mesh
        position={sceneStore.nextPos}
        rotation={[-Math.PI / 2, 0, 0]}
        ref={next}
      >
        <planeBufferGeometry args={[2, 2]} />
        <meshStandardMaterial
          attach="material"
          color={0xff0000}
          roughness={1}
        />
      </mesh>
      <mesh
        position={sceneStore.prevPos}
        rotation={[-Math.PI / 2, 0, 0]}
        ref={prev}
      >
        <planeBufferGeometry args={[2, 2]} />
        <meshStandardMaterial
          attach="material"
          color={0xff0000}
          roughness={1}
        />
      </mesh>
      <mesh
        position={doorStore.nextPlatePos}
        rotation={[-Math.PI / 2, 0, 0]}
        ref={nextDoor}
      >
        <planeBufferGeometry args={[2, 2]} />
        <meshStandardMaterial
          attach="material"
          color={0xff0000}
          roughness={1}
        />
      </mesh>
      <group ref={group} {...props} dispose={null}>
        <primitive object={nodes.Hips} />
        <skinnedMesh
          geometry={nodes.EyeLeft.geometry}
          material={nodes.EyeLeft.material}
          skeleton={nodes.EyeLeft.skeleton}
        />
        <skinnedMesh
          geometry={nodes.EyeRight.geometry}
          material={nodes.EyeRight.material}
          skeleton={nodes.EyeRight.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Body.geometry}
          material={materials["Wolf3D_Body.002"]}
          skeleton={nodes.Wolf3D_Body.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
          material={materials["Wolf3D_Outfit_Bottom.002"]}
          skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
          material={materials["Wolf3D_Outfit_Footwear.002"]}
          skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
        />
        <skinnedMesh
          geometry={nodes.Wolf3D_Outfit_Top.geometry}
          material={materials["Wolf3D_Outfit_Top.002"]}
          skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
        />
        <skinnedMesh
          name="Wolf3D_Head"
          geometry={nodes.Wolf3D_Head.geometry}
          material={materials["Wolf3D_Skin.002"]}
          skeleton={nodes.Wolf3D_Head.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
        />
        <skinnedMesh
          name="Wolf3D_Teeth"
          geometry={nodes.Wolf3D_Teeth.geometry}
          material={materials["Wolf3D_Teeth.002"]}
          skeleton={nodes.Wolf3D_Teeth.skeleton}
          morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
          morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
        />
      </group>
    </>
  );
}

useGLTF.preload("/avatar5.glb");
